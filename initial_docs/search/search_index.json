{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Contributing","text":"<p>Coming soon!</p>"},{"location":"examples/examples/","title":"Examples","text":""},{"location":"examples/examples/#todo","title":"TODO","text":"<p>Adding new inputs to the top flake.nix file</p>"},{"location":"examples/examples/#todo_1","title":"TODO","text":"<p>Building a starter template / boilerplate for future projects</p> <p>If you tend to use the same toolset...</p>"},{"location":"getting-started/install/","title":"Install","text":"<p>[todo: We need to put together a short style guide for consistency, including * Nix (not nix) * NixOS (not NixOs etc.)  * Should we say \"folder\" or \"directory\"? Younger people seem to prefer \"folder\" ]</p>"},{"location":"getting-started/install/#installing-blueprint","title":"Installing Blueprint","text":"<p>Let's create a small project with Nix, and you'll see how to add Blueprint to your project.</p> <ol> <li>Install Nix.</li> <li>Run <code>mkdir my-project &amp;&amp; cd my-project</code></li> <li>Run <code>nix flake init -t github:numtide/blueprint</code>.</li> </ol> <p>Note: After you install Nix, you'll need to enable \"experimental features.\" Find out how here.</p> <p>This will give you a barebone project structure with a single <code>flake.nix</code> file and a single <code>devshell.nix</code> file. (It also provides a basic .envrc, which [TODO] and a starter .gitignore file. Make sure you're aware of this .gitignore file before you accidentally overwrite it.)</p> <p>Normally, without Blueprint, you would typically include a devShell section inside your flake.nix file. In that scenario, when you want to start a new project with a similar toolset, you'll likely need to copy over the devShell section of your flake.nix file to the new project's flake.nix file. But by using Blueprint, we've split out the devShell into its own file, allowing you to simply copy the file over.</p> <p>Here's the starting point of your devShell.nix file:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [ ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n\n  '';\n}\n</code></pre> <p>In a moment we'll look at what you can do with this file. Meanwhile, here's the flake.nix file:</p> <pre><code>{\n  description = \"Simple flake with a devshell\";\n\n  # Add all your dependencies here\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs?ref=nixos-unstable\";\n    blueprint.url = \"github:numtide/blueprint\";\n    blueprint.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  # Load the blueprint\n  outputs = inputs: inputs.blueprint { inherit inputs; };\n}\n</code></pre> <p>You generally shouldn't have to modify this file (unless you're adding new inputs).</p> <p>When you run a nix command (such as <code>nix develop</code>), this flake.nix file is evaluated and Nix loads the Blueprint into the Nix store and makes it available to your current session. Blueprint in turn allows you to read .nix files from multiple locations within your project, including:</p> <ul> <li>The devShell.nix file in the root of your project</li> <li>A folder structure</li> </ul> <p>You create the folder structure based on the available list of folders (found here).</p>"},{"location":"getting-started/install/#a-sample-environment","title":"A Sample Environment","text":"<p>Let's set up a development environment that includes:</p> <ul> <li>Python</li> <li>Python's numpy package</li> </ul> <p>Open up the devshell.nix file in your favorite editor, and update it to look like this:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.python3\n    pkgs.python3Packages.numpy\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n    export PS1=\"(python numpy) $PS1\"\n  '';\n}\n</code></pre> <p>Notice we added two packages, Python and the NumPy Python package.</p> <p>We also added a line inside shellHook. (This line is not required, but it's handy, as it updates the prompt to let you know when you're inside a nix shell.)</p> <p>Now let's hop into the developer shell by typing:</p> <pre><code>nix develop\n</code></pre> <p>After a short moment where Nix downloads the packages, you'll be inside the shell. To verify the packages were installed, type:</p> <pre><code>python\n</code></pre> <p>Then, inside python type:</p> <pre><code>import numpy\n</code></pre> <p>You shouldn't see any error.</p> <p>That's it; go ahead and exit python by typing</p> <pre><code>quit()\n</code></pre> <p>When you're ready to exit the development shell, you can simply type:</p> <pre><code>exit\n</code></pre>"},{"location":"getting-started/install/#what-did-this-demonstrate","title":"What did this demonstrate?","text":"<p>The above demonstrated that the devshell.nix file is now self-contained and can be used without having to add devshell code inside your flake.nix file.</p> <p>There's much more, however, that you can do.</p> <p>Check out:</p> <ul> <li>Examples (including the rest of our Python/NumPy example)</li> <li>Guides</li> <li>Contributing</li> </ul>"},{"location":"getting-started/install/#optional-configuring-direnv","title":"(Optional) Configuring direnv","text":"<p>Included in the initial files created by Blueprint is a filed called .envrc. This file contains code to configure direnv, which allows you to enter a devshell simply by switching to the folder containing your project. That means you don't need to type <code>nix develop</code> after entering the folder. Then when you move up and out of the folder, you'll automatically exit the environment.</p> <p>For more information on configuring this feature, check out our guide at Configuring Direnv</p>"},{"location":"getting-started/install/#creating-a-root-folder","title":"Creating a root folder","text":""},{"location":"getting-started/install/#adding-a-host","title":"Adding a host","text":"<p>TODO</p>"},{"location":"getting-started/install/#adding-a-package","title":"Adding a package","text":"<p>TODO</p>"},{"location":"guides/configuring_direnv/","title":"Configuring Direnv to speed up loading developer environments","text":"<p>Included in the initial files created by Blueprint is a filed called .envrc. This file contains code to configure direnv, which allows you to enter a devshell simply by switching to the folder containing your project. That means you don't need to type <code>nix develop</code> after entering the folder. Then when you move up and out of the folder, you'll automatically exit the environment.</p>"},{"location":"guides/configuring_direnv/#1-install-direnv-if-youre-using-nixos","title":"1. Install direnv. If you're using NixOS:","text":"<p>In the bash shell, type:</p> <pre><code>cd /etc/nixos\n</code></pre> <p>Then open the file called <code>configuration.nix</code> using sudo in conjunction with your favorite editor. For example, if you're using vim:</p> <pre><code>sudo vi configuration.nix\n</code></pre> <p>Locate the line starting with <code>environment.systemPackages</code> and add the direnv package, similar to the following:</p> <pre><code>environment.systemPackages = with pkgs; [ vim git direnv ];\n</code></pre> <p>(In this example, I already had vim and git installed.)</p>"},{"location":"guides/configuring_direnv/#2-add-a-shell-hook","title":"2. Add a shell hook","text":"<p>Now return to your home folder and open .envrc:</p> <pre><code>cd ~\nvi .bashrc\n</code></pre> <p>Add the following line to the end of the file:</p> <pre><code>eval \"$(direnv hook bash)\"\n</code></pre> <p>Save the file and exit. Then either: * Log out and log back in or * Run the same eval command manually to activate it</p> <p>Now direnv is running. Switch to a folder containing a Flake/Blueprint project you previously created. For this example we'll use the one we created in the install page, which includes Python and Python's NumPy package.</p> <pre><code>cd python_numpy\n</code></pre> <p>Note that the first time you do this, you will encounter an error:</p> <pre><code>direnv: error /home/nixos/dev/python_numpy/.envrc is blocked. Run `direnv allow` to approve its content\n</code></pre> <p>Go ahead and type:</p> <pre><code>direnv allow\n</code></pre> <p>Then direnv will automatically launch the devshell for you. Try it! In this case, because we have Python and NumPy installed, type:</p> <pre><code>python\n</code></pre> <p>and a Python shell should open. Then type:</p> <pre><code>import numpy\n</code></pre> <p>Press Enter and you'll see it loaded without an error. Type</p> <pre><code>exit()\n</code></pre>"},{"location":"guides/configuring_direnv/#3-updating-devshellnix","title":"3. Updating devshell.nix","text":"<p>Direnv will automatically reload and relaunch your developer environemnt quietly behind the scenes if you update your devshell.nix file. Let's try it out. Let's add in the pandas library. </p> <p>First, verify that pandas is not installed. From within Python, try to import pandas; after the error message, exit out of Python:</p> <pre><code>&gt;&gt;&gt; import pandas\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nModuleNotFoundError: No module named 'pandas'\n&gt;&gt;&gt;\n&gt;&gt;&gt; exit()\n</code></pre> <p>Now open devshell.nix in your favorite editor, and add the pandas package:</p> <p><pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.python3\n    pkgs.python3Packages.numpy\n    pkgs.python3Packages.pandas\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n\n  '';\n}\n</code></pre> Save it, and you'll briefly see direnv kick in and display some messages. Now return to Python and you'll see that you now have the Pandas package available.</p> <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; \n&gt;&gt;&gt; exit()\n</code></pre>"},{"location":"guides/configuring_direnv/#4-exiting-the-development-shell","title":"4. Exiting the development shell","text":"<p>Finally Now cd up and out of the current folder:</p> <pre><code>cd ...\n</code></pre> <p>You'll see the message:</p> <pre><code>direnv: unloading\n</code></pre> <p>And now to see that you've left the developer environment, try typing <code>python</code> again and you should see a <code>command not found</code> error.</p>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>The flake.nix file offers a few configuration options:</p> <ul> <li>prefix: This lets you specify a directory to hold the folders other than the flake.nix location.</li> <li>systems: Defines which systems the project should be used and deployed on.</li> <li>nixpkgs.config: If set, Blueprint will create a new instance of nixpkgs for each systems.</li> <li>nixpkgs.overlays: If set, blueprint will create a new instance of nixpkgs for each systems.</li> </ul> <p>Below we provide more detail on each, along with examples.</p> <p>[TODO: More detail and each; meanwhile I've copied in the current configuration.md file]</p>"},{"location":"reference/configuration/#prefix","title":"prefix","text":"<p>Set this if you want to load the blueprint from a directory within the repositiry other than the flake location.</p> <p>Default: \".\"</p> <p>Type: string.</p>"},{"location":"reference/configuration/#systems","title":"systems","text":"<p>Defines for which systems the project should be used and deployed on.</p> <p>Default: it will load the <code>inputs.systems</code> flake input, first from the current flake, and then fallback to the blueprint one. (see https://github.com/nix-systems/default).</p> <p>Type: list of <code>&lt;kernel&gt;-&lt;arch&gt;</code> strings.</p> <p>Example:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    systems = [ \"aarch64-linux\" \"x86_64-linux\" ];\n  };\n}\n</code></pre>"},{"location":"reference/configuration/#nixpkgsconfig","title":"nixpkgs.config","text":"<p>If set, blueprint will create a new instance of nixpkgs for each systems, with the passed config.</p> <p>Default: <code>inputs.nixpkgs.legacyPackages.&lt;system&gt;</code>.</p> <p>Type: attrset.</p> <p>Example:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    nixpkgs.config.allowUnfree = true;\n  };\n}\n</code></pre>"},{"location":"reference/configuration/#nixpkgsoverlays","title":"nixpkgs.overlays","text":"<p>NOTE: It's better to use <code>perSystem</code> composition style instead of overlays if you can.</p> <p>If set, blueprint will create a new instance of nixpkgs for each systems, with the passed config.</p> <p>Default: <code>inputs.nixpkgs.legacyPackages.&lt;system&gt;</code>.</p> <p>Type: list of functions.</p> <p>Example:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    nixpkgs.overlays = [\n      inputs.otherflake.overlays.default\n      (final: prev: {\n        git = final.gitMinimal;\n      })\n    ];\n  };\n}\n</code></pre>"},{"location":"reference/reference/","title":"Reference","text":""}]}