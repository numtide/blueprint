{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Contributing","text":"<p>Coming soon!</p>"},{"location":"getting-started/built_in_templates/","title":"Using Templates","text":"<p>Blueprint comes with several templates to help you get started with your project.</p> <p>Note: Feel free to contribute new templates!</p> <p>To install from a template, use the following format; for example, to use the template called system manager, type:</p> <pre><code>nix flake init -t github:numtide/blueprint#system-manager\n</code></pre> <p>where we appended a hash symbol followed by the template name.</p>"},{"location":"getting-started/built_in_templates/#default-template","title":"Default Template","text":"<p>Init command:</p> <pre><code>nix flake init -t github:numtide/blueprint\n</code></pre> <p>This is a bare-bones project as described in install.</p>"},{"location":"getting-started/built_in_templates/#nixos-and-darwin-shared-homes-template","title":"NixOS and Darwin Shared Homes Template","text":"<pre><code>nix flake init -t github:numtide/blueprint#nixos-and-darwin-shared-homes\n</code></pre> <p>This template is a bit of an example plus a template. You'll want to study all the files carefully. It shows how you can define and reuse modules, in this case nixos and home-manager.</p> <p>Look carefully at the folder structure; in this case we're using <code>hosts</code> and <code>modules</code> folders which are both picked up by Blueprint.</p> <p>If you drill down into the folders, you'll see inside the <code>hosts</code> folder, are a <code>my-darwin</code> folder and a <code>my-nixos</code> folder, both of which are imported by Blueprint. This defines the two hosts called <code>my-darwin</code> and <code>my-nixos</code>.</p> <p>Their respective configuration files both import a shared  <code>modules/nixos/host-shared.nix</code> module between them.</p> <p>Also, both hosts define a <code>me</code> user and their home-manager configuration simply imports <code>modules/homes/home-shared.nix</code>.</p> <p>Finally, notice in the root <code>flake.nix</code> we're adding the home-manager and nix-darwin inputs, which serve as dependencies for managing home configurations and macOS integrations, respectively.</p> <p>The idea with this template is that you can use this example to get started on how to share configurations between different system and home environments on different hosts.</p>"},{"location":"getting-started/built_in_templates/#toml-devenvs","title":"Toml-DevEnvs","text":"<p>Members of your team might be intimidated by Nix and flake files, and prefer a more traditional method of configuring their devshells. As such, we provide full support for TOML files.</p> <p>For more information, please visit our devshell repo, which is what powers this template behind-the-scenes.</p>"},{"location":"getting-started/built_in_templates/#system-manager-template","title":"System Manager Template","text":"<pre><code>nix flake init -t github:numtide/blueprint#system-manager\n</code></pre> <p>Notice that the root flake.nix file we're adding the system-manager input, which is our own project. You can find it on GitHub at system-manager, where you can read more information on how to use it.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>In this section we describe the blueprint configuration options:</p> <ul> <li>prefix: This lets you specify a directory to hold the folders other than the flake.nix location.</li> <li>systems: Defines which systems the project should be used and deployed on.</li> <li>nixpkgs.config: If set, Blueprint will create a new instance of nixpkgs for each system.</li> <li>nixpkgs.overlays: If set, blueprint will create a new instance of nixpkgs for each system.</li> </ul> <p>These are available by changing the <code>flake.nix</code> output invocation with additional parameters.</p> <p>Below we provide more detail on each, along with examples.</p>"},{"location":"getting-started/configuration/#prefix","title":"prefix","text":"<p>Set this if you want to load the blueprint from a directory within the repository other than the flake location.</p> <p>Default: \".\"</p> <p>Type: string.</p> <p>For example, add the following prefix line to your output invocation:</p> <pre><code>outputs = inputs:\n  inputs.blueprint {\n    inherit inputs;\n    prefix = \"nix/\";\n  };\n</code></pre> <p>Then, you can add a <code>nix</code> folder inside the same folder that holds your flake file, and place all your folders within this <code>nix</code> folder.</p> <p>Tip: Although you can choose any folder you like, we recommend the name \"nix\" for your folder, as this is becoming the defacto standard.</p>"},{"location":"getting-started/configuration/#systems","title":"systems","text":"<p>Defines for which systems the project should be used and deployed on.</p> <p>Default: it will load the <code>inputs.systems</code> flake input, first from the current flake, and then fallback to the blueprint one. (see https://github.com/nix-systems/default).</p> <p>Type: list of <code>&lt;kernel&gt;-&lt;arch&gt;</code> strings.</p> <p>Example:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    systems = [ \"aarch64-linux\" \"x86_64-linux\" ];\n  };\n}\n</code></pre>"},{"location":"getting-started/configuration/#nixpkgsconfig","title":"nixpkgs.config","text":"<p>If set, blueprint will create a new instance of nixpkgs for each system, with the passed config.</p> <p>Default: <code>inputs.nixpkgs.legacyPackages.&lt;system&gt;</code>.</p> <p>Type: attrset.</p> <p>For example, the following sets the allowUnfree attribute of nixpkgs.config to true:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    nixpkgs.config.allowUnfree = true;\n  };\n}\n</code></pre>"},{"location":"getting-started/configuration/#nixpkgsoverlays","title":"nixpkgs.overlays","text":"<p>NOTE: It's better to use <code>perSystem</code> composition style instead of overlays if you can.</p> <p>If set, blueprint will create a new overlay with the passed config.</p> <p>Type: list of functions.</p> <p>Here's an example that creates a couple of overlays; the first (\"otherflake\") reuses an overlay defined in another flake, and the second, an inline overlay, defines an overlay that replaces the default git package with the smaller gitMinimal:</p> <pre><code>{\n  outputs = inputs: inputs.blueprint {\n    inherit inputs;\n    nixpkgs.overlays = [\n      inputs.otherflake.overlays.default\n      (final: prev: {\n        git = final.gitMinimal;\n      })\n    ];\n  };\n}\n</code></pre>"},{"location":"getting-started/folder_structure/","title":"Folder Structure","text":"<p>Here's a rundown of the options for your folders and default files, followed by detailed explanations of each.</p> <p>Tip: We recommend using a prefix (usually <code>nix/</code>) that specifies a root folder that in turn holds these folders.</p>"},{"location":"getting-started/folder_structure/#high-level","title":"High-level","text":"<ul> <li><code>flake.nix</code> for the default flake</li> <li><code>formatter.nix</code> for the default formatter</li> <li><code>devshell.nix</code> for the default devshell</li> <li><code>package.nix</code> for the default package</li> <li><code>checks/</code> for flake checks.</li> <li><code>devshells/</code> for devshells.</li> <li><code>hosts/</code> for machine configurations.</li> <li><code>lib/</code> for Nix functions.</li> <li><code>modules/</code> for NixOS and other modules.</li> <li><code>packages/</code> for packages.</li> <li><code>templates/</code> for flake templates.</li> </ul>"},{"location":"getting-started/folder_structure/#file-arguments","title":"File arguments","text":"<p>Each file typically gets passed a number of arguments.</p>"},{"location":"getting-started/folder_structure/#per-system","title":"per-system","text":"<p>Some of the files are instantiated multiple times, once per configured system. See configuration on how the list of systems is defined.</p> <p>Those take the following arguments:</p> <ul> <li><code>inputs</code>: maps to the flake inputs.</li> <li><code>flake</code>: maps to the flake itself. It's a shorthand for <code>inputs.self</code>.</li> <li><code>system</code>: the current system attribute.</li> <li><code>perSystem</code>: contains the packages of all the inputs, filtered per system.     Eg: <code>perSystem.nixos-anywhere.default</code> is a shorthand for <code>inputs.nixos-anywhere.packages.&lt;system&gt;.default</code>.</li> <li><code>pkgs</code>: an instance of nixpkgs, see configuration on how it's configured.</li> </ul>"},{"location":"getting-started/folder_structure/#flakenix-for-the-default-flake","title":"flake.nix for the default flake","text":"<p>This is the default flake.nix file. In general you won't need to modify this very much, except for some basic configurations (described here), as you'll be putting your main configurations in their own nix files in their own folders as described here in this document.</p>"},{"location":"getting-started/folder_structure/#formatternix-for-the-default-formatter","title":"formatter.nix for the default formatter","text":"<p>This is where you can provide default formatting. For an example, check out the one used right here in Blueprint.</p>"},{"location":"getting-started/folder_structure/#devshellnix-for-the-default-devshell","title":"devshell.nix for the default devshell","text":"<p>This file holds the configuration for the default devshell, which you can run by simply typing:</p> <pre><code>nix develop\n</code></pre> <p>(We provide an example in our install guide.)</p>"},{"location":"getting-started/folder_structure/#devshells","title":"devshells/","text":"<p>In addition to the default devshell.nix file, you can configure multiple devshells for different scenarios, such as one for a backend build and one for a frontend build. (See later in this doc for an example.) You can configure devshells through either .nix files or through .toml files.</p> <p>The <code>nix</code> files under the devshells folder are expected to evaluate into a shell derivation, normally the result of calling <code>mkShell</code>.</p> <p>There might be many different <code>mkShell</code> implementations, like the one present in <code>nixpkgs</code> or the one from <code>numtide/devshell</code>, and perhaps others. The one you choose depends on the features you might want to use in your environment, like service management, modularity, command menu, etc.</p> <p>Here's an example with the mkShell from nixpkgs:</p> <pre><code># devshell.nix\n# Using mkShell from nixpkgs\n{ pkgs, perSystem, ... }:\npkgs.mkShell {\n  packages = [\n    perSystem.blueprint.default\n    pkgs.terraform\n  ];\n}\n</code></pre> <p>And here's an example of one that uses mkShell from numtide/devshell:</p> <pre><code># devshell.nix\n# Using mkShell from numtide/devshell\n# You are expected to add inputs.devshell in your flake.\n{ pkgs, perSystem, ... }:\nperSystem.devshell.mkShell {\n\n  imports = [\n    # You might want to import other reusable modules\n    (perSystem.devshell.importTOML ./devshell.toml)\n  ];\n\n  env = [\n    # Add bin/ to the beginning of PATH\n    { name = \"PATH\"; prefix = \"bin\"; }\n  ];\n\n  # terraform will be present in the environment menu.\n  commands = [ { package = pkgs.terraform; } ];\n}\n</code></pre>"},{"location":"getting-started/folder_structure/#toml-devshells","title":"TOML devshells","text":"<p><code>toml</code> shells are loaded with devshell but you are required to add <code>inputs.devshell</code> to your flake.</p> <pre><code># devshell.toml\n\n# see https://numtide.github.io/devshell/extending.html\nimports = [ \"./modules/common.toml\" ]\n\n[[commands]]\npackage = \"dbmate\"\n\n[devshell]\npackages = [\"sops\"]\n\n[[env]]\nname = \"DB_PASS\"\neval = \"$(sops --config secrets/sops.yaml --decrypt secrets/db_pass)\"\n\n[serviceGroups.database]\ndescription = \"Runs a database in the backgroup\"\n[serviceGroups.database.services.postgres]\ncommand = \"postgres\"\n[serviceGroups.database.services.memcached]\ncommand = \"memcached\"\n</code></pre>"},{"location":"getting-started/folder_structure/#hosts-for-machine-configurations","title":"Hosts for machine configurations","text":""},{"location":"getting-started/folder_structure/#hostshostnamedefaultnixconfigurationnixdarwin-configurationnixsystem-configurationnix","title":"<code>hosts/&lt;hostname&gt;/(default.nix|configuration.nix|darwin-configuration.nix,system-configuration.nix)</code>","text":"<p>Nix runs on many different operating systems and architecture. When you create a flake, you can define what systems it can produce outputs for.</p> <p>You can configure your project to work with different hosts, which are specific computers or systems.</p> <p>Note: Whereas systems refer to operating systems running in conjunction with a specific architecture, a host refers to specific, single machine (virtual or physical) that runs Nix or NixOS.</p> <p>Each folder contains either a NixOS or nix-darwin configuration:</p>"},{"location":"getting-started/folder_structure/#configurationnix","title":"<code>configuration.nix</code>","text":"<p>Evaluates to a NixOS configuration.</p> <p>Additional values passed:</p> <ul> <li><code>inputs</code> maps to the current flake inputs.</li> <li><code>flake</code> maps to <code>inputs.self</code>.</li> <li><code>hostName</code>: the hostname of the system, which is used to generate the output names.</li> <li><code>perSystem</code>: contains the packages of all the inputs, filtered per system.     Eg: <code>perSystem.nixos-anywhere.default</code> is a shorthand for <code>inputs.nixos-anywhere.packages.&lt;system&gt;.default</code>.</li> </ul> <p>Flake outputs:</p> <ul> <li><code>nixosConfigurations.&lt;hostname&gt;</code></li> <li><code>checks.&lt;system&gt;.nixos-&lt;hostname&gt;</code> - contains the system closure.</li> </ul>"},{"location":"getting-started/folder_structure/#nixos-example","title":"NixOS example","text":"<pre><code>{ flake, inputs, perSystem, ... }:\n{\n  imports = [\n    inputs.srvos.nixosModules.hardware-hetzner-cloud\n    flake.modules.nixos.server\n  ];\n\n  environment.systemPackages = [\n    perSystem.nixos-anywhere.default\n  ];\n\n  nixpkgs.hostPlatform = \"x86_64-linux\";\n\n  system.stateVersion = \"24.05\";\n}\n</code></pre>"},{"location":"getting-started/folder_structure/#darwin-configurationnix","title":"<code>darwin-configuration.nix</code>","text":"<p>Evaluates to a nix-darwin configuration.</p> <p>To support it, also add the following lines to the <code>flake.nix</code> file:</p> <pre><code>{\n  inputs.nix-darwin.url = \"github:LnL7/nix-darwin\";\n}\n</code></pre> <p>Additional values passed:</p> <ul> <li><code>inputs</code> maps to the current flake inputs.</li> <li><code>flake</code> maps to <code>inputs.self</code>.</li> <li><code>hostName</code>: the hostname of the system, which is used to generate the output names.</li> <li><code>perSystem</code>: contains the packages of all the inputs, filtered per system.     Eg: <code>perSystem.nixos-anywhere.default</code> is a shorthand for <code>inputs.nixos-anywhere.packages.&lt;system&gt;.default</code>.</li> </ul> <p>Flake outputs:</p> <ul> <li><code>darwinConfiguration.&lt;hostname&gt;</code></li> <li><code>checks.&lt;system&gt;.darwin-&lt;hostname&gt;</code> - contains the system closure.</li> </ul>"},{"location":"getting-started/folder_structure/#system-configurationnix","title":"<code>system-configuration.nix</code>","text":"<p>Evaluates to a system-manager configuration.</p> <p>To support it, also add the following lines to the <code>flake.nix</code> file:</p> <pre><code>{\n  inputs.system-manager.url = \"github:numtide/system-manager\";\n}\n</code></pre> <p>Additional values passed:</p> <ul> <li><code>inputs</code> maps to the current flake inputs.</li> <li><code>flake</code> maps to <code>inputs.self</code>.</li> <li><code>hostName</code>: the hostname of the system, which is used to generate the output names.</li> <li><code>perSystem</code>: contains the packages of all the inputs, filtered per system.     Eg: <code>perSystem.nixos-anywhere.default</code> is a shorthand for <code>inputs.nixos-anywhere.packages.&lt;system&gt;.default</code>.</li> </ul> <p>Flake outputs:</p> <ul> <li><code>systemConfiguration.&lt;hostname&gt;</code></li> <li><code>checks.&lt;system&gt;.system-&lt;hostname&gt;</code> - contains the system closure.</li> </ul>"},{"location":"getting-started/folder_structure/#defaultnix","title":"<code>default.nix</code>","text":"<p>If present, this file takes precedence over <code>configuration.nix</code> and <code>darwin-configuration.nix</code> and is designed as an escape hatch, allowing the user complete control over <code>nixosSystem</code> or <code>darwinSystem</code> calls.</p> <pre><code>{ flake, inputs, ... }:\n{\n  class = \"nixos\";\n\n  value = inputs.nixpkgs-unstable.lib.nixosSystem {\n    system = \"x86_64-linux\";\n        ...\n  };\n}\n</code></pre> <p>Additional values passed:</p> <ul> <li><code>inputs</code> maps to the current flake inputs.</li> <li><code>flake</code> maps to <code>inputs.self</code>.</li> </ul> <p>Expected return value:</p> <ul> <li><code>class</code> - type of system. Currently \"nixos\" or \"nix-darwin\".</li> <li><code>value</code> - the evaluated system.</li> </ul> <p>Flake outputs:</p> <p>Depending on the system type returned, the flake outputs will be the same as detailed for NixOS or Darwin above.</p>"},{"location":"getting-started/folder_structure/#hostshostnameusersusernamenixusernamehome-configurationnix","title":"<code>hosts/&lt;hostname&gt;/users/(&lt;username&gt;.nix|&lt;username&gt;/home-configuration.nix)</code>","text":"<p>Defines a configuration for a Home Manager user. Users can either be defined as a nix file or directory containing a <code>home-configuration.nix</code> file.</p> <p>Before using this mapping, add the <code>home-manager</code> input to your <code>flake.nix</code> file:</p> <pre><code>{\n  inputs = {\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n}\n</code></pre> <p>Additional values passed:</p> <ul> <li><code>inputs</code> maps to the current flake inputs.</li> <li><code>flake</code> maps to <code>inputs.self</code>.</li> <li><code>perSystem</code>: contains the packages of all the inputs, filtered per system.     Eg: <code>perSystem.nixos-anywhere.default</code> is a shorthand for <code>inputs.nixos-anywhere.packages.&lt;system&gt;.default</code>.</li> <li>other provided module arguments.     Eg: home-manager provides <code>osConfig</code>, the host nixos/nix-darwin configuration.</li> </ul> <p>Tip: The simplest way to have a common/shared user configuration between multiple systems is to create a module at <code>modules/home/&lt;name&gt;.nix</code> (docs), and import that module from <code>inputs.self.homeModules.&lt;name&gt;</code> for each user that should inherit it. This pattern makes it easy to apply system-specific customizations on top of a shared, generic configuration. An example of this setup is shown in the following template: <code>templates/nixos-and-darwin-shared-homes</code>.</p>"},{"location":"getting-started/folder_structure/#nixos-and-nix-darwin","title":"NixOS and nix-darwin","text":"<p>If <code>home-manager</code> is an input to the flake, each host with any users defined will have the appropriate home-manager module imported and each user created automatically.</p> <p>The options <code>home-manager.useGlobalPkgs</code> and <code>home-manager.useUserPkgs</code> will default to true.</p>"},{"location":"getting-started/folder_structure/#standalone-configurations","title":"Standalone configurations","text":"<p>Users are also standalone Home Manager configurations. A user defined as <code>hosts/pc1/users/max.nix</code> can be applied using the <code>home-manager</code> CLI as <code>.#max@pc1</code>. The output name can be elided entirely if the current username and hostname match it, e.g. <code>home-manager switch --flake .</code> (note the lack of <code>#</code>).</p> <p>Because the username is part of the path to the configuration, the <code>home.username</code> option will default to this username. This can be overridden manually. Likewise, <code>home.homeDirectory</code> will be set by default based on the username and operating system (<code>/Users/${username}</code> on macOS, <code>/home/${username}</code> on Linux).</p>"},{"location":"getting-started/folder_structure/#lib-for-nix-functions","title":"lib/ for Nix functions.","text":""},{"location":"getting-started/folder_structure/#libdefaultnix","title":"<code>lib/default.nix</code>","text":"<p>Loaded if it exists.</p> <p>Inputs:</p> <ul> <li><code>flake</code></li> <li><code>inputs</code></li> </ul> <p>Flake outputs:</p> <ul> <li><code>lib</code> - contains the return value of <code>lib/default.nix</code></li> </ul> <p>Eg:</p> <pre><code>{ flake, inputs }:\n{ }\n</code></pre>"},{"location":"getting-started/folder_structure/#modules-for-nixos-and-other-modules","title":"<code>modules/</code> for NixOS and other modules.","text":""},{"location":"getting-started/folder_structure/#modulestypenamenamenix","title":"<code>modules/&lt;type&gt;/(&lt;name&gt;|&lt;name&gt;.nix)</code>","text":"<p>Where the type can be any folder name.</p> <p>For the following folder names, we also map them to the following outputs:</p> <ul> <li>\"darwin\" \u2192 <code>darwinModules.&lt;name&gt;</code></li> <li>\"home\" \u2192 <code>homeModules.&lt;name&gt;</code></li> <li>\"nixos\" \u2192 <code>nixosModules.&lt;name&gt;</code></li> </ul> <p>These and other unrecognized types also exposed as <code>modules.&lt;type&gt;.&lt;name&gt;</code>.</p> <p>If a module is wrapped in a function that accepts one (or more) of the following arguments:</p> <ul> <li><code>flake</code></li> <li><code>inputs</code></li> </ul> <p>Then that function is called before exposing the module as an output. This allows modules to refer to the flake where it is defined, while the module arguments refer to the flake where the module is consumed. Those can be but do not need to be the same flake.</p>"},{"location":"getting-started/folder_structure/#packages-for-packages","title":"<code>packages/</code> for packages.","text":""},{"location":"getting-started/folder_structure/#packagenix-formatternix-packagespnamenixdefaultnix","title":"<code>package.nix</code>, <code>formatter.nix</code>, <code>packages/&lt;pname&gt;(.nix|/default.nix)</code>","text":"<p>This <code>packages/</code> folder contains all your packages.</p> <p>For single-package repositories, we also allow a top-level <code>package.nix</code> that maps to the \"default\" package.</p> <p>Inputs:</p> <p>The per-system values, plus the <code>pname</code> attribute, where pname refers to the package name.</p> <p>Flake outputs:</p> <ul> <li><code>packages.&lt;system&gt;.&lt;pname&gt;</code> - will contain the package</li> <li><code>checks.&lt;system&gt;.pkgs-&lt;pname&gt;</code> - also contains the package for <code>nix flake check</code>.</li> <li><code>checks.&lt;system&gt;.pkgs-&lt;pname&gt;-&lt;tname&gt;</code> - adds all the package <code>passthru.tests</code></li> </ul> <p>To consume a package inside a host from the same flake, <code>perSystem.self.&lt;pname&gt;</code></p>"},{"location":"getting-started/folder_structure/#defaultnix-or-top-level-packagenix","title":"<code>default.nix</code> or top-level <code>package.nix</code>","text":"<p>Takes the \"per-system\" arguments. On top of this, it also takes a <code>pname</code> argument.</p>"},{"location":"getting-started/folder_structure/#checks-for-flake-checks","title":"<code>checks/</code> for flake checks.","text":""},{"location":"getting-started/folder_structure/#checkspnamenixdefaultnix","title":"<code>checks/&lt;pname&gt;(.nix|/default.nix)</code>","text":"<p>The <code>checks/</code> folder can be populated by packages that will be run when <code>nix flake checks</code> is invoked.</p> <p>The flake checks are also populate by some of the other attributes, like <code>packages</code> and <code>hosts</code>.</p> <p>Inputs:</p> <ul> <li>The per-system values, plus the <code>pname</code> attribute.</li> </ul> <p>Flake outputs:</p> <ul> <li><code>checks.&lt;system&gt;.&lt;pname&gt;</code> - will contain the package</li> </ul>"},{"location":"getting-started/folder_structure/#templates-for-flake-templates","title":"<code>templates/</code> for flake templates.","text":""},{"location":"getting-started/folder_structure/#templatesname","title":"<code>templates/&lt;name&gt;/</code>","text":"<p>Use this if you want your project to be initializable using <code>nix flake init</code>.</p> <p>This is what is used by blueprint in the install section.</p> <p>If no name is passed, it will look for the \"default\" folder.</p> <p>Flake outputs:</p> <ul> <li><code>templates.&lt;name&gt; -&gt; path</code></li> </ul>"},{"location":"getting-started/folder_structure/#example-devshells","title":"Example devshells","text":"<p>Because of the presence of Bluprint, nix files contained in these folders and their subfolders are immediately available.</p> <p>As an example, let's create two devshell setups and put them under the devshells folder.</p> <ol> <li>Create a new Blueprint project by creating a new folder and typing <code>nix flake init -t github:numtide/blueprint</code></li> <li>Create a folder inside the project folder called <code>devshells</code> (all lowercase) by typing <code>mkdir devshells</code> (if one doesn't already exist).</li> <li>Move to the packages folder can create two folders under it: <code>mkdir backend &amp;&amp; mkdir frontend</code>.</li> </ol> <p>Go into the backend folder, and create a file called <code>default.nix</code> and paste the following into it:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.nodejs_23\n    pkgs.geany\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n    export PS1=\"(backend) $PS1\"\n  '';\n}\n</code></pre> <p>This code will create a devshell that includes node.js and the IDE called Geany. It also  sets the prompt to show the word <code>(backend)</code> as a reminder you're working in the bakcend.  You can use this devshell for backend development.</p> <p>Now move over to the <code>frontend</code> folder. Create a file called <code>default.nix</code> and paste the following into it:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.nodejs_23\n    pkgs.geany\n    pkgs.nodePackages.\"@angular/cli\"\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n    export PS1=\"(frontend) $PS1\"\n  '';\n}\n</code></pre> <p>This is similar to the backend, but you'll notice it also includes the CLI tools for Angular for frontend development. This code also sets the prompt to say <code>(frontend)</code> to remind you you're working in the front end.</p> <p>Save both files and move to the root folder of the project.</p> <p>Now you can invoke either development shell by typing one of the following:</p> <ul> <li><code>nix develop .#backend</code> to launch the back end shell</li> <li><code>nix develop .#frontend</code> to launch the front end shell</li> </ul>"},{"location":"getting-started/folder_structure/#example-hosts-and-modules","title":"Example Hosts and Modules","text":"<p>This example comes from one of our available templates called NixOS and Darwin Shared Homes Template.</p> <p>Here we create two Blueprint folders, hosts and modules with the following subfolders:</p> <pre><code>root folder\n\u251c\u2500\u2500 flake.nix\n\u251c\u2500\u2500 hosts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 my-darwin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 darwin-configuration.nix\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 users\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 me\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 home-configuration.nix\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 my-nixos\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 configuration.nix\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 users\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 me\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 home-configuration.nix\n\u251c\u2500\u2500 modules\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 home\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 home-shared.nix\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nixos\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 host-shared.nix\n\u2514\u2500\u2500 README.md\n</code></pre> <p>If you run the above command, this is the set of files you'll get. Take a look at the difference between darwin-configuration.nix under hosts/my-darwin and configuration.nix under hosts/my-nixos.</p>"},{"location":"getting-started/folder_structure/#example-checks","title":"Example Checks","text":"<p>Let's look at how you can put individual tests in the checks folder.</p> <p>Start by creating a new folder and initializing the Flake with Blueprint:</p> <pre><code>nix flake init -t github:numtide/blueprint\n</code></pre> <p>Then create a folder called src, and another folder next to it called checks.</p> <p>In the src folder, create three python files:</p> <ol> <li>main.py</li> </ol> <pre><code>from utils import string_length\n\nif __name__ == \"__main__\":\n    test_str = \"hello\"\n    print(f\"Length of '{test_str}' is {string_length(test_str)}\")\n</code></pre> <ol> <li>utils.py</li> </ol> <pre><code>def string_length(s):\n    return len(s)\n</code></pre> <p>(As you can see, we're keeping this incredibly simple for demonstration purposes.)</p> <ol> <li>test_length.py</li> </ol> <pre><code>from utils import string_length\n\ndef test_string_length():\n    assert string_length(\"hello\") == 5\n    assert string_length(\"\") == 0\n    assert string_length(\"squirrel!\") == 8\n</code></pre> <p>Next, in the checks folder, create a file called test.nix. (Really you can call it anything you want, as long as it has a nix extension.) And place the following in it:</p> <pre><code>{ pkgs, system, ... }:\n\nlet\n  pythonEnv = pkgs.python3.withPackages (ps: with ps; [ pytest ]);\nin\npkgs.runCommand \"string-length-test\"\n  {\n    buildInputs = [ pythonEnv ];\n    src = ./../src;\n  } ''\n    cp -r $src/* .\n    # Run pytest, save output to file\n    if ! pytest &gt; result.log 2&gt;&amp;1; then\n      cat result.log &gt;&amp;2  # dump the error to stderr so nix shows it\n      exit 1\n    fi\n    touch $out\n  ''\n</code></pre> <p>Now run:</p> <pre><code>nix flake check\n</code></pre> <p>And your test will run. Because it's correct, you won't see any output. So perhaps try adjusting the function to make it purposely return the wrong number:</p> <pre><code>def string_length(s):\n    return len(s) + 1\n</code></pre> <p>Then when you run <code>nix flake check</code> you should see the output from the pytest tool.</p> <p>Note: You'll actually only see the last part of the output. At the bottom will be a message explaining how to view the full logs. It will be similar to this:</p> <p>For full logs, run 'nix log /nix/store/8qqfm9i0b3idljh1n14yqhc12c5dv8j2-string-length-test.drv'. </p> <p>From there you can see the full output from pytest, including the assertion failures.</p>"},{"location":"getting-started/install/","title":"Installing Blueprint","text":"<p>Let's create a small project with Nix, and you'll see how to add Blueprint to your project.</p> <ol> <li>Install Nix or use NixOS.</li> <li>Run <code>mkdir my-project &amp;&amp; cd my-project</code></li> <li>Run <code>nix flake init -t github:numtide/blueprint</code>.</li> </ol> <p>Note: After you install Nix, you'll need to enable \"experimental features.\"</p> <p>This will give you a barebone project structure with a single <code>flake.nix</code> file and a single <code>devshell.nix</code> file. (It also provides a basic .envrc, which lets you configure direnv and a starter .gitignore file. Make sure you're aware of this .gitignore file before you accidentally overwrite it.)</p> <p>Normally, without Blueprint, you would typically include a devShell section inside your flake.nix file. In that scenario, when you want to start a new project with a similar toolset, you'll likely need to copy over the devShell section of your flake.nix file to the new project's flake.nix file. But by using Blueprint, we've split out the devShell into its own file, allowing you to simply copy the file over.</p> <p>Here's the starting point of your devShell.nix file:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [ ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n\n  '';\n}\n</code></pre> <p>In a moment we'll look at what you can do with this file. Meanwhile, here's the flake.nix file:</p> <pre><code>{\n  description = \"Simple flake with a devshell\";\n\n  # Add all your dependencies here\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs?ref=nixos-unstable\";\n    blueprint.url = \"github:numtide/blueprint\";\n    blueprint.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  # Load the blueprint\n  outputs = inputs: inputs.blueprint { inherit inputs; };\n}\n</code></pre> <p>You generally shouldn't have to modify this file (unless you're adding new inputs).</p> <p>When you run a nix command (such as <code>nix develop</code>), this flake.nix file is evaluated and Nix loads the Blueprint into the Nix store and makes it available to your current session. Blueprint in turn allows you to read .nix files from multiple locations within your project, including:</p> <ul> <li>The devShell.nix file in the root of your project</li> <li>A folder structure</li> </ul> <p>You create the folder structure based on the available list of folders found here.</p>"},{"location":"getting-started/install/#a-sample-environment","title":"A Sample Environment","text":"<p>Let's set up a development environment that includes:</p> <ul> <li>Python</li> <li>Python's numpy package</li> </ul> <p>Tip: In this section we'll be creating a default developer environment. You can also set up multiple developer environments and place them in the devshell folder as shown in the devshell section here.</p> <p>Open up the devshell.nix file in your favorite editor, and update it to look like this:</p> <pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.python3\n    pkgs.python3Packages.numpy\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n    export PS1=\"(python numpy) $PS1\"\n  '';\n}\n</code></pre> <p>Notice we added two packages, Python and the NumPy Python package.</p> <p>We also added a line inside shellHook. (This line is not required, but it's handy, as it updates the prompt to let you know when you're inside a nix shell.)</p> <p>Now let's hop into the developer shell by typing:</p> <pre><code>nix develop\n</code></pre> <p>After a short moment where Nix downloads the packages, you'll be inside the shell. To verify the packages were installed, type:</p> <pre><code>python\n</code></pre> <p>Then, inside python type:</p> <pre><code>import numpy\n</code></pre> <p>You shouldn't see any error.</p> <p>That's it; go ahead and exit python by typing</p> <pre><code>quit()\n</code></pre> <p>When you're ready to exit the development shell, you can simply type:</p> <pre><code>exit\n</code></pre>"},{"location":"getting-started/install/#what-did-this-demonstrate","title":"What did this demonstrate?","text":"<p>The above demonstrated that the devshell.nix file is now self-contained and can be used without having to add devshell code inside your flake.nix file.</p> <p>There's much more, however, that you can do.</p> <p>Check out:</p> <ul> <li>Examples (including the rest of our Python/NumPy example)</li> <li>Guides</li> <li>Contributing</li> </ul>"},{"location":"getting-started/install/#adding-folders","title":"Adding folders","text":"<p>Next, we'll add some folders into your project to give you an idea of how the folder system works.</p> <p>Tip: It's often good practice to put the folder structure inside its own root folder. That way the folders will be grouped together and easy to distinguish from other folders. As an example, look at NumTide treefmt. </p> <p>Let's start with a root folder to hold the other folders. We'll use \"nix\" as that's the standard one we've created. Open up your root flake.nix file and expand the outputs line so it takes up multiple lines, and then add in the following prefix attribute:</p> <pre><code>  outputs = inputs:\n    inputs.blueprint {\n      inherit inputs;\n      prefix = \"nix/\";\n    };\n</code></pre> <p>Now create a <code>nix</code> folder at the root of your project alongside the flake.nix and devshell.nix files.</p> <p>Now you're ready to create some folders.</p> <p>First, remember that folders are detected automatically by Blueprint. That way, you can drop in place pre-built packages. For example, on another project, you might have built a package that configures mysql. In that project you placed it in a folder called packages. You can then simply create a folder in your new project also called packages, and drop the mysql file in there, and you're good to go. No messing around with giant monolithic flake.nix file.</p> <p>Let's do something similar. Let's add some documentation to your app. Suppose we want to set up MkDocs with your project.</p> <p>Tip: Remember, the whole point of Nix is to be able to set up reproducible environments. What that means is you don't need to install MkDocs globally. Instead, you can configure it directly in your project.</p> <ol> <li>Under the <code>nix</code> folder, create another folder called <code>packages</code> (all lowercase).</li> <li>Then under <code>packages</code> create a folder called <code>docs</code>.</li> <li>Inside the <code>docs</code> folder, paste the following code into a file called <code>default.nix</code>:</li> </ol> <pre><code>{\n  pkgs,\n  perSystem,\n  ...\n}:\npkgs.stdenvNoCC.mkDerivation {\n  name = \"docs\";\n\n  unpackPhase = ''\n    cp ${../../../mkdocs.yml} mkdocs.yaml\n    cp -r ${../../../docs} docs\n  '';\n\n  nativeBuildInputs = with pkgs.python3Packages; [\n    mike\n    mkdocs\n    mkdocs-material\n    mkdocs-awesome-nav\n  ];\n\n  buildPhase = ''\n    mkdocs build\n  '';\n\n  installPhase = ''\n    mv site $out\n  '';\n}\n</code></pre> <p>Tip: Because Blueprint is present, this code will get loaded automatically as needed. And notice how it can be reused; indeed for this example, we simply copied it over from the Blueprint project itself.</p> <p>This code defines a derivation that builds the documentation. Before you can use it, however, you'll need some documentation. So again off the root folder of your project, create a folder called <code>docs</code>. This is where you'll put the documentation.</p> <p>Inside the <code>docs</code> folder, create file called <code>index.md</code> and paste in perhaps the following:</p> <pre><code># Welcome to my amazing app!\nWe've built this amazing app and hope you enjoy it!\n</code></pre> <p>Next, we need a file that configures MkDocs called mkdocs.yml. In the root folder, create the file <code>mkdocs.yml</code> and paste the following in it:</p> <pre><code>site_name: AwesomeProject\n</code></pre> <p>Now let's build the docs using the mkdocs app. We'll build a static site. From your root folder, type:</p> <pre><code>nix build .#docs\n</code></pre> <p>You'll see a <code>results</code> folder appear. This contains the output from the mkdocs, which is the built website. If you want to run the built-in mkdocs server to try out your site, type:</p> <pre><code>nix develop .#docs\n</code></pre> <p>Notice by calling nix develop, we're entering a development shell. But that happens only after we run the derivation. The derivation will compile our documents into a static site again (if necessary) and make the mkdocs command available to us while in the shell.</p> <p>Open up a browser and head to <code>http://127.0.0.1:8000/</code> and you should see the documentation open with a header \"Welcome to my amazing app!\" and so on.</p>"},{"location":"getting-started/install/#what-did-this-demonstrate_1","title":"What did this demonstrate?","text":"<p>Without Blueprint installed, you would have had to place the above default.nix file containing the mkdocs code inside your main flake.nix file, or link to it manually. But because of Blueprint, your setup will automatically scan a set of predetermined folders (including Packages) for files and find them automatically, making them available to use.</p> <p>Tip: If you want to see what folders are available, head over to our  folder strutures documentation.</p>"},{"location":"getting-started/install/#optional-configuring-direnv","title":"(Optional) Configuring direnv","text":"<p>Included in the initial files created by Blueprint is a filed called .envrc. This file contains code to configure direnv, which allows you to enter a devshell simply by switching to the folder containing your project. That means you don't need to type <code>nix develop</code> after entering the folder. Then when you move up and out of the folder, you'll automatically exit the environment.</p> <p>For more information on configuring this feature, check out our guide at Configuring Direnv</p>"},{"location":"guides/configuring_direnv/","title":"Configuring Direnv to speed up loading developer environments","text":"<p>Included in the initial files created by Blueprint is a filed called .envrc. This file contains code to configure direnv, which allows you to enter a devshell simply by switching to the folder containing your project. That means you don't need to type <code>nix develop</code> after entering the folder. Then when you move up and out of the folder, you'll automatically exit the environment.</p>"},{"location":"guides/configuring_direnv/#1-install-direnv-if-youre-using-nixos","title":"1. Install direnv. If you're using NixOS:","text":"<p>In the bash shell, type:</p> <pre><code>cd /etc/nixos\n</code></pre> <p>Then open the file called <code>configuration.nix</code> using sudo in conjunction with your favorite editor. For example, if you're using vim:</p> <pre><code>sudo vi configuration.nix\n</code></pre> <p>Locate the line starting with <code>environment.systemPackages</code> and add the direnv package, similar to the following:</p> <pre><code>environment.systemPackages = with pkgs; [ vim git direnv ];\n</code></pre> <p>(In this example, I already had vim and git installed.)</p>"},{"location":"guides/configuring_direnv/#2-add-a-shell-hook","title":"2. Add a shell hook","text":"<p>Now return to your home folder and open .envrc:</p> <pre><code>cd ~\nvi .bashrc\n</code></pre> <p>Add the following line to the end of the file:</p> <pre><code>eval \"$(direnv hook bash)\"\n</code></pre> <p>Save the file and exit. Then either: * Log out and log back in or * Run the same eval command manually to activate it</p> <p>Now direnv is running. Switch to a folder containing a Flake/Blueprint project you previously created. For this example we'll use the one we created in the install page, which includes Python and Python's NumPy package.</p> <pre><code>cd python_numpy\n</code></pre> <p>Note that the first time you do this, you will encounter an error:</p> <pre><code>direnv: error /home/nixos/dev/python_numpy/.envrc is blocked. Run `direnv allow` to approve its content\n</code></pre> <p>Go ahead and type:</p> <pre><code>direnv allow\n</code></pre> <p>Then direnv will automatically launch the devshell for you. Try it! In this case, because we have Python and NumPy installed, type:</p> <pre><code>python\n</code></pre> <p>and a Python shell should open. Then type:</p> <pre><code>import numpy\n</code></pre> <p>Press Enter and you'll see it loaded without an error. Type</p> <pre><code>exit()\n</code></pre>"},{"location":"guides/configuring_direnv/#3-updating-devshellnix","title":"3. Updating devshell.nix","text":"<p>Direnv will automatically reload and relaunch your developer environemnt quietly behind the scenes if you update your devshell.nix file. Let's try it out. Let's add in the pandas library. </p> <p>First, verify that pandas is not installed. From within Python, try to import pandas; after the error message, exit out of Python:</p> <pre><code>&gt;&gt;&gt; import pandas\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nModuleNotFoundError: No module named 'pandas'\n&gt;&gt;&gt;\n&gt;&gt;&gt; exit()\n</code></pre> <p>Now open devshell.nix in your favorite editor, and add the pandas package:</p> <p><pre><code>{ pkgs }:\npkgs.mkShell {\n  # Add build dependencies\n  packages = [\n    pkgs.python3\n    pkgs.python3Packages.numpy\n    pkgs.python3Packages.pandas\n  ];\n\n  # Add environment variables\n  env = { };\n\n  # Load custom bash code\n  shellHook = ''\n\n  '';\n}\n</code></pre> Save it, and you'll briefly see direnv kick in and display some messages. Now return to Python and you'll see that you now have the Pandas package available.</p> <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; \n&gt;&gt;&gt; exit()\n</code></pre>"},{"location":"guides/configuring_direnv/#4-exiting-the-development-shell","title":"4. Exiting the development shell","text":"<p>Finally Now cd up and out of the current folder:</p> <pre><code>cd ...\n</code></pre> <p>You'll see the message:</p> <pre><code>direnv: unloading\n</code></pre> <p>And now to see that you've left the developer environment, try typing <code>python</code> again and you should see a <code>command not found</code> error.</p>"},{"location":"guides/examples/","title":"Examples","text":""},{"location":"guides/examples/#todo","title":"TODO","text":"<p>Adding new inputs to the top flake.nix file</p>"},{"location":"guides/examples/#todo_1","title":"TODO","text":"<p>Building a starter template / boilerplate for future projects</p> <p>If you tend to use the same toolset...</p>"}]}